<pre class='metadata'>
Title: `mdspan` and CTAD
H1: <code>mdspan</code> and CTAD
Shortname: D2299
Revision: 3
Status: D
Group: WG21
Audience: WG21
Editor: Bryce Adelstein Lelbach (he/him/his) — Library Evolution Chair, NVIDIA, brycelelbach@gmail.com
URL: https://wg21.link/P2299
!Source: <a href="https://github.com/brycelelbach/wg21_p2299_mdspan_and_ctad/blob/main/mdspan_and_ctad.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p2299_mdspan_and_ctad/issues
Metadata Order: Editor, This Version, Source, Issue Tracking, Project, Audience
Markup Shorthands: markdown yes
Toggle Diffs: no
No Abstract: yes
Boilerplate: style-syntax-highlighting off
</pre>

<style>
table, th, tr, td {
  border: 2px solid black !important;
}
@media (prefers-color-scheme: dark) {
  table, th, tr, td {
    border: 2px solid white !important;
  }
}
pre {
  margin-top: 0px;
  margin-bottom: 0px;
}
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}
.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
math, span.math {
  font-family: serif;
  font-style: italic;
}
ul {
  list-style-type: "— ";
}
blockquote {
  counter-reset: paragraph;
}
div.numbered, div.newnumbered {
  margin-left: 2em;
  margin-top: 1em;
  margin-bottom: 1em;
}
div.numbered:before, div.newnumbered:before {
  position: absolute;
  margin-left: -2em;
  display-style: block;
}
div.numbered:before {
  content: counter(paragraph);
  counter-increment: paragraph;
}
div.newnumbered:before {
  content: "�";
}
div.numbered ul, div.newnumbered ul {
  counter-reset: list_item;
}
div.numbered li, div.newnumbered li {
  margin-left: 3em;
}
div.numbered li:before, div.newnumbered li:before {
  position: absolute;
  margin-left: -4.8em;
  display-style: block;
}
div.numbered li:before {
  content: "(" counter(paragraph) "." counter(list_item) ")";
  counter-increment: list_item;
}
div.newnumbered li:before {
  content: "(�." counter(list_item) ")";
  counter-increment: list_item;
}
</style>

# Introduction # {#introduction}

[[P0009R11]] proposes adding non-owning multidimensional span abstractions
  to the C++ Standard Library; `basic_mdspan`, which is fully generic and
  can represent any kind of multidimensional data, and `mdspan`, a
  convenience template alias for simpler use cases.

```
template <class ElementType, class Extents, class LayoutPolicy = layout_right,
          class AccessorPolicy = accessor_basic<ElementType>>
struct basic_mdspan;

template <class ElementType, size_t... Extents>
using mdspan = basic_mdspan<ElementType, extents<Extents...>>;
```

In the `basic_mdspan`/`span` interface, extents can be either static, e.g.
  expressed at compile time:

```
mdspan<double, 64, 64> a(data);
```

or dynamic, e.g. expressed at run time:

```
mdspan<double, dynamic_extent, dynamic_extent> a(data, 64, 64);
```

You can also use a mix of the two styles:

```
mdspan<double, 64, dynamic_extent> a(data, 64);
```

While `basic_mdspan` and `mdspan` are powerful, the spelling of instantiations
  can be verbose, especially for the common case where all extents are dynamic.

Using class template argument deduction (introduced in C++17) and alias
  template argument deduction (introduced in C++20), we can make it a easier to
  use `mdspan` with all dynamic extents:

<table class="before_after">
<tr class="before_after">
<th>Before
<th>After
<tr class="before_after">
<td><code>mdspan&lt;double, dynamic_extent, dynamic_extent&gt; a(data, 64, 64);</code>
<td><code>mdspan a(data, 64, 64);</code>
</table>

To make this work, we need to add a deduction guide for `basic_mdspan`.
Through the power of alias template argument deduction, `mdspan` will be
  able to use said deduction guide as well.

Here's [an example](https://godbolt.org/z/z3s4KG9ae) implementation of such a
  deduction guide for `basic_mdspan`.

In earlier versions of this paper, it was unclear whether such a deduction
  guide would work for the alias template `mdspan`, as attempts to construct
  one that functioned as intended had failed.
However, we have since learned that the this is due to bugs in the two
  implementations that currently support alias template deduction, MSVC
  and GCC.
Those bugs have been reported to the respective compilers and hopefully
  will be fixed soon.

Here's [an example](https://godbolt.org/z/nofs8bT9E) of the current
  implementation bugs that prevent the deduction guide from working for
  `mdspan`.

# Wording # {#wording}

The following changes are relative to the `mdspan` proposal ([[P0009R11]]).

The � character is used to denote a placeholder number which shall be selected by the editor.

Modify the header synopsis for `<mdspan>` in [**mdspan.syn**] as follows:

<blockquote>
<b>22.7.� Header `<mdspan>` synopsis <span style="float: right;">[mdspan.syn]</span></b>

<pre><code>
namespace std {
  // [mdspan.extents], class template extents
  template<size_t... Extents>
    class extents;

  // [mdspan.layout], Layout mapping policies
  class layout_left;
  class layout_right;
  class layout_stride;

  // [mdspan.accessor.basic]
  template&lt;class ElementType&gt;
    class default_accessor;

  // [mdspan.basic], class template mdspan
  template&lt;class ElementType, class Extents, class LayoutPolicy = layout_right,
           class AccessorPolicy = default_accessor&lt;ElementType&gt;&gt;
    class basic_mdspan;

<div class="ins">  template &lt;class ElementType, class... IndexTypes&gt;
  explicit basic_mdspan(ElementType*, IndexTypes...)
    -> basic_mdspan&lt;ElementType, extents&lt;[] (auto) constexpr
                                         { return dynamic_extent; }
                                         (identity&lt;IndexTypes&gt;{})...&gt;&gt;;</div>
  template&lt;class T, size_t... Extents&gt;
    using mdspan = basic_mdspan&lt;T, extents&lt;Extents...&gt;&gt;;

  // [mdspan.submdspan]
  template&lt;class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers&gt;
    constexpr basic_mdspan&lt;<i>see below</i>&gt;
    submdspan(const basic_mdspan&lt;ElementType, Extents, LayoutPolicy, AccessorPolicy&gt;&amp; m,
              SliceSpecifiers... specs) noexcept;

  // tag supporting submdspan
  struct full_extent_t { explicit full_extent_t() = default; };
  inline constexpr full_extent_t full_extent = full_extent_t{};
}
</code></pre>
</blockquote>

<pre class=biblio>
{

  "P0009R11": {
    "authors": [
      "Christian Trott",
      "D.S. Hollman",
      "Damien Lebrun-Grandie",
      "Mark Hoemmen",
      "Daniel Sunderland",
      "H. Carter Edwards",
      "Bryce Adelstein Lelbach",
      "Mauro Bianco",
      "Ben Sander",
      "Athanasios Iliopoulos",
      "John Michopoulos",
      "Nevin Liber"
    ],
    "href": "https://isocpp.org/files/papers/P0009R11.html",
    "title": "<code>mdspan</code>",
    "date": "2020-05-11"
  }
}
</pre>
